
Uno_zadanie1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  000003b0  00000444  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000003b0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800110  00800110  00000454  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000454  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000484  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000060  00000000  00000000  000004c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000918  00000000  00000000  00000524  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000765  00000000  00000000  00000e3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000052d  00000000  00000000  000015a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000108  00000000  00000000  00001ad0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000434  00000000  00000000  00001bd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000002ca  00000000  00000000  0000200c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  000022d6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__vector_2>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 89 00 	jmp	0x112	; 0x112 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 9b 00 	jmp	0x136	; 0x136 <__vector_16>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_18>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__vector_21>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e0 eb       	ldi	r30, 0xB0	; 176
  7c:	f3 e0       	ldi	r31, 0x03	; 3
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 31       	cpi	r26, 0x10	; 16
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a0 e1       	ldi	r26, 0x10	; 16
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a2 31       	cpi	r26, 0x12	; 18
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 df 00 	call	0x1be	; 0x1be <main>
  9e:	0c 94 d6 01 	jmp	0x3ac	; 0x3ac <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_18>:
#include <avr/interrupt.h>

volatile unsigned char val = 0, en=1, cmd;
volatile unsigned char ADCValue;

ISR(USART_RX_vect){
  a6:	1f 92       	push	r1
  a8:	0f 92       	push	r0
  aa:	0f b6       	in	r0, 0x3f	; 63
  ac:	0f 92       	push	r0
  ae:	11 24       	eor	r1, r1
  b0:	8f 93       	push	r24
	cmd = UDR0;
  b2:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  b6:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <cmd>
}
  ba:	8f 91       	pop	r24
  bc:	0f 90       	pop	r0
  be:	0f be       	out	0x3f, r0	; 63
  c0:	0f 90       	pop	r0
  c2:	1f 90       	pop	r1
  c4:	18 95       	reti

000000c6 <__vector_21>:

ISR(ADC_vect){
  c6:	1f 92       	push	r1
  c8:	0f 92       	push	r0
  ca:	0f b6       	in	r0, 0x3f	; 63
  cc:	0f 92       	push	r0
  ce:	11 24       	eor	r1, r1
  d0:	8f 93       	push	r24
	ADCValue = ADCH;
  d2:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
  d6:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__data_end>

}
  da:	8f 91       	pop	r24
  dc:	0f 90       	pop	r0
  de:	0f be       	out	0x3f, r0	; 63
  e0:	0f 90       	pop	r0
  e2:	1f 90       	pop	r1
  e4:	18 95       	reti

000000e6 <__vector_2>:
ISR(INT1_vect){
  e6:	1f 92       	push	r1
  e8:	0f 92       	push	r0
  ea:	0f b6       	in	r0, 0x3f	; 63
  ec:	0f 92       	push	r0
  ee:	11 24       	eor	r1, r1
  f0:	8f 93       	push	r24
  f2:	9f 93       	push	r25
	if(en)
  f4:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
  f8:	88 23       	and	r24, r24
  fa:	21 f0       	breq	.+8      	; 0x104 <__vector_2+0x1e>
		PORTB ^= 0x01;
  fc:	95 b1       	in	r25, 0x05	; 5
  fe:	81 e0       	ldi	r24, 0x01	; 1
 100:	89 27       	eor	r24, r25
 102:	85 b9       	out	0x05, r24	; 5
}
 104:	9f 91       	pop	r25
 106:	8f 91       	pop	r24
 108:	0f 90       	pop	r0
 10a:	0f be       	out	0x3f, r0	; 63
 10c:	0f 90       	pop	r0
 10e:	1f 90       	pop	r1
 110:	18 95       	reti

00000112 <__vector_11>:

/*ISR(TIMER1_OVF_vect){ // normal mode
	PORTB ^= 0x01;
}
*/
ISR(TIMER1_COMPA_vect){ // CTC mode
 112:	1f 92       	push	r1
 114:	0f 92       	push	r0
 116:	0f b6       	in	r0, 0x3f	; 63
 118:	0f 92       	push	r0
 11a:	11 24       	eor	r1, r1
 11c:	8f 93       	push	r24
 11e:	9f 93       	push	r25
	PORTB ^= 0x01;
 120:	95 b1       	in	r25, 0x05	; 5
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	89 27       	eor	r24, r25
 126:	85 b9       	out	0x05, r24	; 5
}
 128:	9f 91       	pop	r25
 12a:	8f 91       	pop	r24
 12c:	0f 90       	pop	r0
 12e:	0f be       	out	0x3f, r0	; 63
 130:	0f 90       	pop	r0
 132:	1f 90       	pop	r1
 134:	18 95       	reti

00000136 <__vector_16>:

ISR(TIMER0_OVF_vect){ // PWM
 136:	1f 92       	push	r1
 138:	0f 92       	push	r0
 13a:	0f b6       	in	r0, 0x3f	; 63
 13c:	0f 92       	push	r0
 13e:	11 24       	eor	r1, r1
 140:	8f 93       	push	r24
	OCR0A = ADCValue;
 142:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
 146:	87 bd       	out	0x27, r24	; 39
}
 148:	8f 91       	pop	r24
 14a:	0f 90       	pop	r0
 14c:	0f be       	out	0x3f, r0	; 63
 14e:	0f 90       	pop	r0
 150:	1f 90       	pop	r1
 152:	18 95       	reti

00000154 <USART_Init>:

void USART_Init(void){
	/*Set baud rate */
	UBRR0H = (unsigned char)0;
 154:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UBRR0L = (unsigned char)16;
 158:	80 e1       	ldi	r24, 0x10	; 16
 15a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UCSR0A |= (1<<U2X0);
 15e:	e0 ec       	ldi	r30, 0xC0	; 192
 160:	f0 e0       	ldi	r31, 0x00	; 0
 162:	80 81       	ld	r24, Z
 164:	82 60       	ori	r24, 0x02	; 2
 166:	80 83       	st	Z, r24
	/* Enable receiver and transmitter */
	UCSR0B = (1<<TXEN0) | (1<<RXEN0) | (1<<RXCIE0);
 168:	88 e9       	ldi	r24, 0x98	; 152
 16a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	/* Set frame format: 8data, 2stop bit */
	UCSR0C = (0<<USBS0)|(3<<UCSZ00);
 16e:	86 e0       	ldi	r24, 0x06	; 6
 170:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 174:	08 95       	ret

00000176 <USART0_send>:
}
	
void USART0_send(char data){
	while ( !(UCSR0A & (1<<UDRE0)) );
 176:	e0 ec       	ldi	r30, 0xC0	; 192
 178:	f0 e0       	ldi	r31, 0x00	; 0
 17a:	90 81       	ld	r25, Z
 17c:	95 ff       	sbrs	r25, 5
 17e:	fd cf       	rjmp	.-6      	; 0x17a <USART0_send+0x4>
	UDR0 = data;
 180:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 184:	08 95       	ret

00000186 <USART0_sendString>:
}

void USART0_sendString(char* data){
 186:	cf 93       	push	r28
 188:	df 93       	push	r29
 18a:	ec 01       	movw	r28, r24
	unsigned char i=0;
	
	while(data[i] != 0){
 18c:	38 81       	ld	r19, Y
 18e:	33 23       	and	r19, r19
 190:	99 f0       	breq	.+38     	; 0x1b8 <USART0_sendString+0x32>
 192:	20 e0       	ldi	r18, 0x00	; 0
		while ( !(UCSR0A & (1<<UDRE0)) );
 194:	e0 ec       	ldi	r30, 0xC0	; 192
 196:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = data[i];
 198:	46 ec       	ldi	r20, 0xC6	; 198
 19a:	50 e0       	ldi	r21, 0x00	; 0

void USART0_sendString(char* data){
	unsigned char i=0;
	
	while(data[i] != 0){
		while ( !(UCSR0A & (1<<UDRE0)) );
 19c:	90 81       	ld	r25, Z
 19e:	95 ff       	sbrs	r25, 5
 1a0:	fd cf       	rjmp	.-6      	; 0x19c <USART0_sendString+0x16>
		UDR0 = data[i];
 1a2:	da 01       	movw	r26, r20
 1a4:	3c 93       	st	X, r19
		if(i==255)
 1a6:	2f 3f       	cpi	r18, 0xFF	; 255
 1a8:	39 f0       	breq	.+14     	; 0x1b8 <USART0_sendString+0x32>
			break;
		i++;
 1aa:	2f 5f       	subi	r18, 0xFF	; 255
}

void USART0_sendString(char* data){
	unsigned char i=0;
	
	while(data[i] != 0){
 1ac:	de 01       	movw	r26, r28
 1ae:	a2 0f       	add	r26, r18
 1b0:	b1 1d       	adc	r27, r1
 1b2:	3c 91       	ld	r19, X
 1b4:	31 11       	cpse	r19, r1
 1b6:	f2 cf       	rjmp	.-28     	; 0x19c <USART0_sendString+0x16>
		UDR0 = data[i];
		if(i==255)
			break;
		i++;
	}
}
 1b8:	df 91       	pop	r29
 1ba:	cf 91       	pop	r28
 1bc:	08 95       	ret

000001be <main>:
	unsigned int cnt = 0;
	unsigned char sendADC = 0;
	unsigned char lastADCValue=0;
    unsigned char tempVal1;
	
	DDRB |= 0x2F;
 1be:	84 b1       	in	r24, 0x04	; 4
 1c0:	8f 62       	ori	r24, 0x2F	; 47
 1c2:	84 b9       	out	0x04, r24	; 4
	PORTB |= 0x21;
 1c4:	85 b1       	in	r24, 0x05	; 5
 1c6:	81 62       	ori	r24, 0x21	; 33
 1c8:	85 b9       	out	0x05, r24	; 5
	
	DDRD = 0x40;
 1ca:	20 e4       	ldi	r18, 0x40	; 64
 1cc:	2a b9       	out	0x0a, r18	; 10
    
	EICRA |= (1<<ISC10 | 1<<ISC11);
 1ce:	e9 e6       	ldi	r30, 0x69	; 105
 1d0:	f0 e0       	ldi	r31, 0x00	; 0
 1d2:	80 81       	ld	r24, Z
 1d4:	8c 60       	ori	r24, 0x0C	; 12
 1d6:	80 83       	st	Z, r24
	EIMSK |= 0x02;
 1d8:	e9 9a       	sbi	0x1d, 1	; 29
	
	// ADC Init
	ADMUX = (1<<REFS0) | (1<<ADLAR);
 1da:	80 e6       	ldi	r24, 0x60	; 96
 1dc:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	DIDR0 = (1<<ADC0D);
 1e0:	91 e0       	ldi	r25, 0x01	; 1
 1e2:	90 93 7e 00 	sts	0x007E, r25	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	ADCSRB = 0;
 1e6:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	ADCSRA = (1<<ADEN) | (1<<ADATE) | (1<<ADIE) | 0x07;
 1ea:	ea e7       	ldi	r30, 0x7A	; 122
 1ec:	f0 e0       	ldi	r31, 0x00	; 0
 1ee:	8f ea       	ldi	r24, 0xAF	; 175
 1f0:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADSC);
 1f2:	80 81       	ld	r24, Z
 1f4:	80 64       	ori	r24, 0x40	; 64
 1f6:	80 83       	st	Z, r24
	TCCR1B = (1<<CS11);
	TIMSK1 = (1<<TOIE1);
	*/
	
	//Timer1 Init - CTC mode
	TCCR1A = (1<<COM1A0);
 1f8:	20 93 80 00 	sts	0x0080, r18	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
	TCCR1B = (1<<WGM12) | (1<<CS11);
 1fc:	8a e0       	ldi	r24, 0x0A	; 10
 1fe:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	TIMSK1 = (1<<OCIE1A);
 202:	82 e0       	ldi	r24, 0x02	; 2
 204:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
	OCR1A = 0x8000;
 208:	20 e0       	ldi	r18, 0x00	; 0
 20a:	30 e8       	ldi	r19, 0x80	; 128
 20c:	30 93 89 00 	sts	0x0089, r19	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 210:	20 93 88 00 	sts	0x0088, r18	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	
	//Timer0 Init - PWM
	TCCR0A = (1<<COM0A1) | (1<<WGM01) | (1<<WGM00);
 214:	83 e8       	ldi	r24, 0x83	; 131
 216:	84 bd       	out	0x24, r24	; 36
	TCCR0B = (1<<CS01) | (1<<CS00);
 218:	83 e0       	ldi	r24, 0x03	; 3
 21a:	85 bd       	out	0x25, r24	; 37
	TIMSK0 = (1<<TOIE0);
 21c:	90 93 6e 00 	sts	0x006E, r25	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	OCR0A = 128;
 220:	80 e8       	ldi	r24, 0x80	; 128
 222:	87 bd       	out	0x27, r24	; 39
	
	//USART Init
	USART_Init();
 224:	0e 94 aa 00 	call	0x154	; 0x154 <USART_Init>
	
	sei();
 228:	78 94       	sei
{
	//unsigned char val=0, en=1;
	unsigned char val2=0, lastvalue = 0;//, cmd=0;
	unsigned int cnt = 0;
	unsigned char sendADC = 0;
	unsigned char lastADCValue=0;
 22a:	51 2c       	mov	r5, r1
int main(void)
{
	//unsigned char val=0, en=1;
	unsigned char val2=0, lastvalue = 0;//, cmd=0;
	unsigned int cnt = 0;
	unsigned char sendADC = 0;
 22c:	d0 e0       	ldi	r29, 0x00	; 0
}

int main(void)
{
	//unsigned char val=0, en=1;
	unsigned char val2=0, lastvalue = 0;//, cmd=0;
 22e:	c0 e0       	ldi	r28, 0x00	; 0
	sei();
	/* Replace with your application code */
    while (1) 
    {
		_delay_ms(1);
		PORTB ^= 0x20;
 230:	68 94       	set
 232:	77 24       	eor	r7, r7
 234:	75 f8       	bld	r7, 5
			{
			case 'b':
				PORTB ^= 0x04;
				break;
			case 'a':
				sendADC = 1;
 236:	66 24       	eor	r6, r6
 238:	63 94       	inc	r6
					OCR1A = 0x0080;
				else
					OCR1A = OCR1A<<1;
				break;
			case 'p':
				USART0_send(TCNT1H);USART0_send(TCNT1L);
 23a:	0f 2e       	mov	r0, r31
 23c:	f5 e8       	ldi	r31, 0x85	; 133
 23e:	af 2e       	mov	r10, r31
 240:	b1 2c       	mov	r11, r1
 242:	f0 2d       	mov	r31, r0
 244:	0f 2e       	mov	r0, r31
 246:	f4 e8       	ldi	r31, 0x84	; 132
 248:	cf 2e       	mov	r12, r31
 24a:	d1 2c       	mov	r13, r1
 24c:	f0 2d       	mov	r31, r0
		
		if(cmd != 0){
			switch (cmd)
			{
			case 'b':
				PORTB ^= 0x04;
 24e:	68 94       	set
 250:	33 24       	eor	r3, r3
 252:	32 f8       	bld	r3, 2
					tempVal1--;
					TCCR1B = (TCCR1B & 0xF8) | tempVal1;
				//USART0_sendString("OK\r");
				GTCCR = 0x01;
			case ']':
				if(OCR1A==0x8000)
 254:	0f 2e       	mov	r0, r31
 256:	f8 e8       	ldi	r31, 0x88	; 136
 258:	ef 2e       	mov	r14, r31
 25a:	f1 2c       	mov	r15, r1
 25c:	f0 2d       	mov	r31, r0
					OCR1A = 0x0080;
 25e:	68 94       	set
 260:	88 24       	eor	r8, r8
 262:	87 f8       	bld	r8, 7
 264:	91 2c       	mov	r9, r1
				TCCR1B = (TCCR1B & 0xF8) | tempVal1;
				//USART0_sendString("OK\r");
				GTCCR = 0x01;
				break;
			case '-':
				tempVal1 = TCCR1B & 0x07;
 266:	01 e8       	ldi	r16, 0x81	; 129
 268:	10 e0       	ldi	r17, 0x00	; 0
				if(tempVal1 == 1)
					tempVal1 = 0x05;
 26a:	0f 2e       	mov	r0, r31
 26c:	f5 e0       	ldi	r31, 0x05	; 5
 26e:	2f 2e       	mov	r2, r31
 270:	f0 2d       	mov	r31, r0
		if((PIND & 0x10) != 0x10)
		{
			if(val2 == 0){
				USART0_sendString("Green pressed\r");
				en = !en;
				PORTB ^= 0x02;
 272:	68 94       	set
 274:	44 24       	eor	r4, r4
 276:	41 f8       	bld	r4, 1
 278:	03 c0       	rjmp	.+6      	; 0x280 <main+0xc2>
			}
			val2 = 1;
		}else val2 = 0;
 27a:	c0 e0       	ldi	r28, 0x00	; 0
 27c:	01 c0       	rjmp	.+2      	; 0x280 <main+0xc2>
			if(val2 == 0){
				USART0_sendString("Green pressed\r");
				en = !en;
				PORTB ^= 0x02;
			}
			val2 = 1;
 27e:	c6 2d       	mov	r28, r6
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 280:	8f e9       	ldi	r24, 0x9F	; 159
 282:	9f e0       	ldi	r25, 0x0F	; 15
 284:	01 97       	sbiw	r24, 0x01	; 1
 286:	f1 f7       	brne	.-4      	; 0x284 <main+0xc6>
 288:	00 c0       	rjmp	.+0      	; 0x28a <main+0xcc>
 28a:	00 00       	nop
	sei();
	/* Replace with your application code */
    while (1) 
    {
		_delay_ms(1);
		PORTB ^= 0x20;
 28c:	85 b1       	in	r24, 0x05	; 5
 28e:	87 25       	eor	r24, r7
 290:	85 b9       	out	0x05, r24	; 5
 292:	ef e3       	ldi	r30, 0x3F	; 63
 294:	fc e9       	ldi	r31, 0x9C	; 156
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	f1 f7       	brne	.-4      	; 0x296 <main+0xd8>
 29a:	00 c0       	rjmp	.+0      	; 0x29c <main+0xde>
 29c:	00 00       	nop
	//	if(UCSR0A & (1<<RXC0)){
		//	cmd = UDR0;
		//	PORTB ^= 0x04;
	//	}
		
		if(cmd != 0){
 29e:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cmd>
 2a2:	88 23       	and	r24, r24
 2a4:	09 f4       	brne	.+2      	; 0x2a8 <main+0xea>
 2a6:	56 c0       	rjmp	.+172    	; 0x354 <main+0x196>
			switch (cmd)
 2a8:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cmd>
 2ac:	81 36       	cpi	r24, 0x61	; 97
 2ae:	89 f0       	breq	.+34     	; 0x2d2 <main+0x114>
 2b0:	40 f4       	brcc	.+16     	; 0x2c2 <main+0x104>
 2b2:	8d 32       	cpi	r24, 0x2D	; 45
 2b4:	29 f1       	breq	.+74     	; 0x300 <main+0x142>
 2b6:	8d 35       	cpi	r24, 0x5D	; 93
 2b8:	89 f1       	breq	.+98     	; 0x31c <main+0x15e>
 2ba:	8b 32       	cpi	r24, 0x2B	; 43
 2bc:	09 f0       	breq	.+2      	; 0x2c0 <main+0x102>
 2be:	48 c0       	rjmp	.+144    	; 0x350 <main+0x192>
 2c0:	10 c0       	rjmp	.+32     	; 0x2e2 <main+0x124>
 2c2:	80 37       	cpi	r24, 0x70	; 112
 2c4:	e9 f1       	breq	.+122    	; 0x340 <main+0x182>
 2c6:	8a 37       	cpi	r24, 0x7A	; 122
 2c8:	51 f0       	breq	.+20     	; 0x2de <main+0x120>
 2ca:	82 36       	cpi	r24, 0x62	; 98
 2cc:	09 f0       	breq	.+2      	; 0x2d0 <main+0x112>
 2ce:	40 c0       	rjmp	.+128    	; 0x350 <main+0x192>
 2d0:	02 c0       	rjmp	.+4      	; 0x2d6 <main+0x118>
			{
			case 'b':
				PORTB ^= 0x04;
				break;
			case 'a':
				sendADC = 1;
 2d2:	d6 2d       	mov	r29, r6
 2d4:	3d c0       	rjmp	.+122    	; 0x350 <main+0x192>
		
		if(cmd != 0){
			switch (cmd)
			{
			case 'b':
				PORTB ^= 0x04;
 2d6:	85 b1       	in	r24, 0x05	; 5
 2d8:	83 25       	eor	r24, r3
 2da:	85 b9       	out	0x05, r24	; 5
				break;
 2dc:	39 c0       	rjmp	.+114    	; 0x350 <main+0x192>
			case 'a':
				sendADC = 1;
				break;
			case 'z':
				sendADC = 0;
 2de:	d0 e0       	ldi	r29, 0x00	; 0
				break;
 2e0:	37 c0       	rjmp	.+110    	; 0x350 <main+0x192>
			case '+':
				tempVal1 = TCCR1B & 0x07;
 2e2:	f8 01       	movw	r30, r16
 2e4:	80 81       	ld	r24, Z
 2e6:	87 70       	andi	r24, 0x07	; 7
				if(tempVal1 == 0x05)
 2e8:	85 30       	cpi	r24, 0x05	; 5
 2ea:	11 f0       	breq	.+4      	; 0x2f0 <main+0x132>
					tempVal1 = 1;
				else
					tempVal1++;
 2ec:	8f 5f       	subi	r24, 0xFF	; 255
 2ee:	01 c0       	rjmp	.+2      	; 0x2f2 <main+0x134>
				sendADC = 0;
				break;
			case '+':
				tempVal1 = TCCR1B & 0x07;
				if(tempVal1 == 0x05)
					tempVal1 = 1;
 2f0:	86 2d       	mov	r24, r6
				else
					tempVal1++;
				TCCR1B = (TCCR1B & 0xF8) | tempVal1;
 2f2:	f8 01       	movw	r30, r16
 2f4:	90 81       	ld	r25, Z
 2f6:	98 7f       	andi	r25, 0xF8	; 248
 2f8:	89 2b       	or	r24, r25
 2fa:	80 83       	st	Z, r24
				//USART0_sendString("OK\r");
				GTCCR = 0x01;
 2fc:	63 bc       	out	0x23, r6	; 35
				break;
 2fe:	28 c0       	rjmp	.+80     	; 0x350 <main+0x192>
			case '-':
				tempVal1 = TCCR1B & 0x07;
 300:	f8 01       	movw	r30, r16
 302:	80 81       	ld	r24, Z
 304:	87 70       	andi	r24, 0x07	; 7
				if(tempVal1 == 1)
 306:	81 30       	cpi	r24, 0x01	; 1
 308:	11 f0       	breq	.+4      	; 0x30e <main+0x150>
					tempVal1 = 0x05;
				else
					tempVal1--;
 30a:	81 50       	subi	r24, 0x01	; 1
 30c:	01 c0       	rjmp	.+2      	; 0x310 <main+0x152>
				GTCCR = 0x01;
				break;
			case '-':
				tempVal1 = TCCR1B & 0x07;
				if(tempVal1 == 1)
					tempVal1 = 0x05;
 30e:	82 2d       	mov	r24, r2
				else
					tempVal1--;
					TCCR1B = (TCCR1B & 0xF8) | tempVal1;
 310:	f8 01       	movw	r30, r16
 312:	90 81       	ld	r25, Z
 314:	98 7f       	andi	r25, 0xF8	; 248
 316:	89 2b       	or	r24, r25
 318:	80 83       	st	Z, r24
				//USART0_sendString("OK\r");
				GTCCR = 0x01;
 31a:	63 bc       	out	0x23, r6	; 35
			case ']':
				if(OCR1A==0x8000)
 31c:	f7 01       	movw	r30, r14
 31e:	80 81       	ld	r24, Z
 320:	91 81       	ldd	r25, Z+1	; 0x01
 322:	81 15       	cp	r24, r1
 324:	90 48       	sbci	r25, 0x80	; 128
 326:	21 f4       	brne	.+8      	; 0x330 <main+0x172>
					OCR1A = 0x0080;
 328:	f7 01       	movw	r30, r14
 32a:	91 82       	std	Z+1, r9	; 0x01
 32c:	80 82       	st	Z, r8
 32e:	10 c0       	rjmp	.+32     	; 0x350 <main+0x192>
				else
					OCR1A = OCR1A<<1;
 330:	f7 01       	movw	r30, r14
 332:	80 81       	ld	r24, Z
 334:	91 81       	ldd	r25, Z+1	; 0x01
 336:	88 0f       	add	r24, r24
 338:	99 1f       	adc	r25, r25
 33a:	91 83       	std	Z+1, r25	; 0x01
 33c:	80 83       	st	Z, r24
 33e:	08 c0       	rjmp	.+16     	; 0x350 <main+0x192>
				break;
			case 'p':
				USART0_send(TCNT1H);USART0_send(TCNT1L);
 340:	f5 01       	movw	r30, r10
 342:	80 81       	ld	r24, Z
 344:	0e 94 bb 00 	call	0x176	; 0x176 <USART0_send>
 348:	f6 01       	movw	r30, r12
 34a:	80 81       	ld	r24, Z
 34c:	0e 94 bb 00 	call	0x176	; 0x176 <USART0_send>
			break;
			
			default:
				break;
			}
			cmd=0;
 350:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <cmd>
		}
		
		if(sendADC)
 354:	dd 23       	and	r29, r29
 356:	b1 f0       	breq	.+44     	; 0x384 <main+0x1c6>
			if( (ADCValue-lastADCValue)>=10 || (lastADCValue-ADCValue)>=10 ){
 358:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
 35c:	25 2d       	mov	r18, r5
 35e:	30 e0       	ldi	r19, 0x00	; 0
 360:	90 e0       	ldi	r25, 0x00	; 0
 362:	82 1b       	sub	r24, r18
 364:	93 0b       	sbc	r25, r19
 366:	0a 97       	sbiw	r24, 0x0a	; 10
 368:	3c f4       	brge	.+14     	; 0x378 <main+0x1ba>
 36a:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
 36e:	28 1b       	sub	r18, r24
 370:	31 09       	sbc	r19, r1
 372:	2a 30       	cpi	r18, 0x0A	; 10
 374:	31 05       	cpc	r19, r1
 376:	34 f0       	brlt	.+12     	; 0x384 <main+0x1c6>
				USART0_send(ADCValue);
 378:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
 37c:	0e 94 bb 00 	call	0x176	; 0x176 <USART0_send>
			lastADCValue = ADCValue;
 380:	50 90 10 01 	lds	r5, 0x0110	; 0x800110 <__data_end>
		}
		
		if((PIND & 0x10) != 0x10)
 384:	4c 99       	sbic	0x09, 4	; 9
 386:	79 cf       	rjmp	.-270    	; 0x27a <main+0xbc>
		{
			if(val2 == 0){
 388:	c1 11       	cpse	r28, r1
 38a:	79 cf       	rjmp	.-270    	; 0x27e <main+0xc0>
				USART0_sendString("Green pressed\r");
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	91 e0       	ldi	r25, 0x01	; 1
 390:	0e 94 c3 00 	call	0x186	; 0x186 <USART0_sendString>
				en = !en;
 394:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
 398:	86 2d       	mov	r24, r6
 39a:	91 11       	cpse	r25, r1
 39c:	80 e0       	ldi	r24, 0x00	; 0
 39e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
				PORTB ^= 0x02;
 3a2:	85 b1       	in	r24, 0x05	; 5
 3a4:	84 25       	eor	r24, r4
 3a6:	85 b9       	out	0x05, r24	; 5
			}
			val2 = 1;
 3a8:	c6 2d       	mov	r28, r6
 3aa:	6a cf       	rjmp	.-300    	; 0x280 <main+0xc2>

000003ac <_exit>:
 3ac:	f8 94       	cli

000003ae <__stop_program>:
 3ae:	ff cf       	rjmp	.-2      	; 0x3ae <__stop_program>
